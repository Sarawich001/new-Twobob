<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TwoBob Tactics - Tetris Multiplayer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .screen {
            display: none;
            text-align: center;
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Menu Screen */
        .menu-screen {
            display: block;
        }

        .game-title {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 2rem;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .connection-status {
            margin-bottom: 2rem;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
        }

        .connected {
            background: rgba(76, 175, 80, 0.3);
            border: 2px solid #4CAF50;
        }

        .disconnected {
            background: rgba(244, 67, 54, 0.3);
            border: 2px solid #f44336;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            max-width: 300px;
            margin: 0 auto;
        }

        .btn {
            padding: 15px 30px;
            font-size: 1.1rem;
            font-weight: bold;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            color: white;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-decoration: none;
            display: inline-block;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-single-player {
            background: linear-gradient(45deg, #ff9500, #ff6b00);
        }

        .btn-single-player:hover {
            background: linear-gradient(45deg, #ffb84d, #ff8533);
        }

        /* Waiting Screen */
        .room-info {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
            backdrop-filter: blur(10px);
        }

        .room-id {
            font-size: 2rem;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 1rem;
        }

        .players-list {
            list-style: none;
            margin: 1rem 0;
        }

        .players-list li {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
        }

        .players-list li.current-player {
            background: rgba(255, 215, 0, 0.3);
            border: 2px solid #ffd700;
        }

        /* Game Screen */
        .game-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 2rem;
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
        }

        .game-canvas-container {
            position: relative;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        #game-canvas {
            border: 2px solid #333;
            border-radius: 10px;
            background: #000;
        }

        .game-stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-weight: bold;
        }

        /* Mobile Controls */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(10px);
        }

        .control-button {
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 10px;
            padding: 15px;
            margin: 5px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-button:active {
            background: rgba(255,255,255,0.4);
            transform: scale(0.95);
        }

        /* Form Styles */
        .form-group {
            margin: 1rem 0;
        }

        .form-input {
            width: 100%;
            padding: 15px;
            font-size: 1rem;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
            color: white;
            backdrop-filter: blur(10px);
        }

        .form-input::placeholder {
            color: rgba(255,255,255,0.7);
        }

        .form-input:focus {
            outline: 2px solid #4ecdc4;
            background: rgba(255,255,255,0.2);
        }

        /* Game Over Modal */
        .game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 2rem;
            border-radius: 15px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .modal-content h2 {
            margin-bottom: 1rem;
            font-size: 2rem;
        }

        .scores {
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .game-title {
                font-size: 2rem;
            }

            .mobile-controls {
                display: block;
            }

            #game-canvas {
                width: 90vw;
                height: 60vh;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 10px;
            }
        }

        /* Status indicator */
        .status-display {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 10px;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Menu Screen -->
        <div id="menu-screen" class="screen menu-screen">
            <h1 class="game-title">üéÆ TwoBob Tactics</h1>
            <div id="connection-status" class="connection-status disconnected">
                üî¥ ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
            </div>
            <div class="menu-buttons">
                <button id="btn-create-room" class="btn">üè† ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡πâ‡∏≠‡∏á</button>
                <button id="btn-join-room" class="btn">üö™ ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°‡∏´‡πâ‡∏≠‡∏á</button>
                <button id="btn-single-player" class="btn btn-single-player">üéØ ‡πÄ‡∏•‡πà‡∏ô‡∏Ñ‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß</button>
            </div>
        </div>

        <!-- Create Room Dialog -->
        <div id="create-room-screen" class="screen">
            <h2>üè† ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà</h2>
            <div class="form-group">
                <input id="create-player-name" class="form-input" type="text" placeholder="‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô" maxlength="20">
            </div>
            <div class="menu-buttons">
                <button id="btn-confirm-create" class="btn">‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡πâ‡∏≠‡∏á</button>
                <button class="btn" onclick="showScreen('menu-screen')">‚ùå ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å</button>
            </div>
        </div>

        <!-- Join Room Dialog -->
        <div id="join-room-screen" class="screen">
            <h2>üö™ ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°‡∏´‡πâ‡∏≠‡∏á</h2>
            <div class="form-group">
                <input id="join-player-name" class="form-input" type="text" placeholder="‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô" maxlength="20">
            </div>
            <div class="form-group">
                <input id="join-room-id" class="form-input" type="text" placeholder="‡∏£‡∏´‡∏±‡∏™‡∏´‡πâ‡∏≠‡∏á" maxlength="10">
            </div>
            <div class="menu-buttons">
                <button id="btn-confirm-join" class="btn">‚úÖ ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°</button>
                <button class="btn" onclick="showScreen('menu-screen')">‚ùå ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å</button>
            </div>
        </div>

        <!-- Waiting Screen -->
        <div id="waiting-screen" class="screen">
            <div class="room-info">
                <div class="room-id">
                    ‡∏´‡πâ‡∏≠‡∏á: <span id="room-id-display">-</span>
                </div>
                <h3>‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á:</h3>
                <ul id="players-list" class="players-list">
                </ul>
                <div id="ready-indicators">
                    <div id="ready-indicator-1">Player 1: ‡∏£‡∏≠...</div>
                    <div id="ready-indicator-2">Player 2: ‡∏£‡∏≠...</div>
                </div>
            </div>
            <div class="menu-buttons">
                <button id="btn-ready" class="btn" disabled>üéÆ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏•‡πà‡∏ô</button>
                <button id="btn-leave-room" class="btn">üö™ ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏´‡πâ‡∏≠‡∏á</button>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="screen">
            <div class="game-container">
                <div class="game-canvas-container">
                    <canvas id="game-canvas" width="800" height="600"></canvas>
                </div>
            </div>

            <!-- Mobile Controls -->
            <div class="mobile-controls">
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;">
                    <button class="control-button" onclick="gameClient?.handleMobileInput('rotate')">‚Ü∂</button>
                    <button class="control-button" onclick="gameClient?.handleMobileInput('rotate')">‚Üë</button>
                    <button class="control-button" onclick="gameClient?.handleMobileInput('hard-drop')">üíß</button>
                    <button class="control-button" onclick="gameClient?.handleMobileInput('move-left')">‚Üê</button>
                    <button class="control-button" onclick="gameClient?.handleMobileInput('move-down')">‚Üì</button>
                    <button class="control-button" onclick="gameClient?.handleMobileInput('move-right')">‚Üí</button>
                </div>
                <div style="text-align: center; margin-top: 10px; font-size: 0.8rem;">
                    ‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏ä‡πâ swipe: ‚Üê‚Üí ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô, ‚Üë ‡∏´‡∏°‡∏∏‡∏ô, ‚Üì ‡∏î‡∏£‡∏≠‡∏õ
                </div>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="screen">
            <div id="winner-message" class="winner-announcement">üéâ ‡∏Ñ‡∏∏‡∏ì‡∏ä‡∏ô‡∏∞!</div>
            <div class="final-scores">
                <h3>‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢</h3>
                <div class="score-row">
                    <span>Player 1:</span>
                    <span id="final-score-p1">0</span>
                </div>
                <div class="score-row">
                    <span>Player 2:</span>
                    <span id="final-score-p2">0</span>
                </div>
            </div>
            <div class="menu-buttons">
                <button id="btn-play-again" class="btn">üîÑ ‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</button>
                <button class="btn" onclick="window.location.reload()">üè† ‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏°‡∏ô‡∏π</button>
            </div>
        </div>
    </div>

    <!-- Status Display -->
    <div id="status" class="status-display">‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠...</div>

    <!-- Instructions -->
    <div style="position: fixed; bottom: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 10px; font-size: 0.8rem; max-width: 300px;">
        <strong>‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°:</strong><br>
        ‚Üê‚Üí ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô | ‚Üë ‡∏´‡∏°‡∏∏‡∏ô | ‚Üì ‡πÄ‡∏£‡πà‡∏á | Space ‡∏î‡∏£‡∏≠‡∏õ<br>
        üì± ‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠: ‡πÉ‡∏ä‡πâ swipe ‡∏´‡∏£‡∏∑‡∏≠‡∏õ‡∏∏‡πà‡∏°‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á
    </div>

    <script>
        // Global game client instance
        let gameClient = null;

        // UI Management Functions
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.style.display = 'none';
            });
            document.getElementById(screenId).style.display = 'block';
        }

        function updateConnectionStatus(connected) {
            const statusEl = document.getElementById('connection-status');
            if (connected) {
                statusEl.className = 'connection-status connected';
                statusEl.innerHTML = 'üü¢ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏•‡πâ‡∏ß';
            } else {
                statusEl.className = 'connection-status disconnected';
                statusEl.innerHTML = 'üî¥ ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠';
            }
        }

        function updatePlayersList(players) {
            const listEl = document.getElementById('players-list');
            listEl.innerHTML = '';
            
            players.forEach((player, index) => {
                const li = document.createElement('li');
                li.textContent = `${player.name} ${player.ready ? '‚úÖ' : '‚è≥'}`;
                if (player.id === gameClient?.socket?.id) {
                    li.classList.add('current-player');
                }
                listEl.appendChild(li);
            });
        }

        // Enhanced OptimizedTetrisClient with UI integration
        class OptimizedTetrisClient {
            constructor() {
                this.socket = null;
                this.gameState = null;
                this.prevGameState = null;
                this.dropInterval = null;
                this.animationFrame = null;
                this.playerNumber = null;
                this.roomId = null;
                this.TILE_SIZE = 30;
                
                // Canvas setup for better performance
                this.setupCanvas();
                
                // Object pooling for DOM elements
                this.blockPool = [];
                this.activeBlocks = new Set();
                
                // Performance monitoring
                this.performanceMetrics = {
                    frameCount: 0,
                    lastTime: performance.now(),
                    fps: 60
                };
                
                // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Socket.io
                this.initializeSocket();
                this.setupEventListeners();
                this.startRenderLoop();
            }

            // Socket.io initialization
            initializeSocket() {
                this.socket = io('http://localhost:3000', {
                    transports: ['websocket', 'polling']
                });

                this.setupSocketHandlers();
            }

            // Socket Event Handlers
            setupSocketHandlers() {
                this.socket.on('connect', () => {
                    console.log('üîå Connected to server:', this.socket.id);
                    updateConnectionStatus(true);
                    this.updateStatus('‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏•‡πâ‡∏ß');
                });

                this.socket.on('disconnect', (reason) => {
                    console.log('üîå Disconnected:', reason);
                    updateConnectionStatus(false);
                    this.updateStatus('‡∏Ç‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠');
                });

                this.socket.on('room-joined', (data) => {
                    console.log('üè† Joined room:', data.roomId);
                    this.roomId = data.roomId;
                    this.playerNumber = data.playerNumber;
                    
                    document.getElementById('room-id-display').textContent = data.roomId;
                    this.updateStatus(`Player ${data.playerNumber} - Room: ${data.roomId}`);
                    
                    showScreen('waiting-screen');
                    document.getElementById('btn-ready').disabled = false;
                });

                this.socket.on('room-players-update', (players) => {
                    updatePlayersList(players);
                });

                this.socket.on('game-started', (gameState) => {
                    console.log('üéÆ Game started!');
                    this.gameState = gameState;
                    showScreen('game-screen');
                    this.startGameLoop();
                });

                this.socket.on('game-state-update', (gameState) => {
                    this.gameState = gameState;
                });

                this.socket.on('game-delta', (delta) => {
                    this.applyDelta(delta);
                });

                this.socket.on('game-over', (result) => {
                    console.log('üèÜ Game over:', result);
                    this.handleGameOver(result);
                });

                this.socket.on('rate-limited', () => {
                    console.warn('‚ö†Ô∏è Rate limited - slow down!');
                });

                this.socket.on('error', (error) => {
                    console.error('‚ùå Socket error:', error);
                    this.updateStatus('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error);
                });
            }

            // UI Integration Methods
            createRoom(playerName) {
                if (this.socket && this.socket.connected) {
                    this.socket.emit('create-room', { 
                        playerName: playerName || `Player_${Math.random().toString(36).substr(2, 5)}`
                    });
                }
            }

            joinRoom(roomId, playerName) {
                if (this.socket && this.socket.connected) {
                    this.socket.emit('join-room', { 
                        roomId: roomId,
                        playerName: playerName || `Player_${Math.random().toString(36).substr(2, 5)}`
                    });
                }
            }

            playerReady() {
                if (this.socket && this.socket.connected) {
                    this.socket.emit('player-ready');
                }
            }

            leaveRoom() {
                if (this.socket && this.socket.connected) {
                    this.socket.emit('leave-room');
                    showScreen('menu-screen');
                }
            }

            // Game Input Handling
            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.handleKeyPress(e);
                });

                // Touch controls for mobile
                this.setupTouchControls();
            }

            setupTouchControls() {
                const canvas = document.getElementById('game-canvas');
                if (!canvas) return;

                let startX, startY;

                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    startX = touch.clientX;
                    startY = touch.clientY;
                });

                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (!startX || !startY) return;

                    const touch = e.changedTouches[0];
                    const deltaX = touch.clientX - startX;
                    const deltaY = touch.clientY - startY;
                    const minSwipeDistance = 30;

                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        if (Math.abs(deltaX) > minSwipeDistance) {
                            this.handleMobileInput(deltaX > 0 ? 'move-right' : 'move-left');
                        }
                    } else {
                        if (Math.abs(deltaY) > minSwipeDistance) {
                            this.handleMobileInput(deltaY > 0 ? 'move-down' : 'rotate');
                        }
                    }
                });
            }

            handleMobileInput(action) {
                if (!this.gameState?.gameStarted) return;
                if (!this.socket?.connected) return;

                this.socket.emit('game-action', { type: action });
            }

            handleKeyPress(e) {
                if (!this.gameState?.gameStarted) return;
                if (!this.socket?.connected) return;

                const actions = {
                    'ArrowLeft': { type: 'move-left' },
                    'ArrowRight': { type: 'move-right' },
                    'ArrowDown': { type: 'move-down' },
                    'ArrowUp': { type: 'rotate' },
                    ' ': { type: 'hard-drop' }
                };

                if (actions[e.key]) {
                    e.preventDefault();
                    this.socket.emit('game-action', actions[e.key]);
                }
            }

            // Delta Updates
            applyDelta(delta) {
                if (!this.gameState) return;

                const playerKey = `player${delta.playerNumber}`;
                const playerState = this.gameState[playerKey];

                delta.changes.forEach(change => {
                    switch (change.type) {
                        case 'position':
                            playerState.currentX = change.to.x;
                            playerState.currentY = change.to.y;
                            break;

                        case 'rotation':
                            playerState.currentPiece.shape = change.shape;
                            break;

                        case 'hard-drop':
                            playerState.currentY = change.newY;
                            playerState.score += change.scoreGain;
                            break;

                        case 'piece-placed':
                            Object.assign(playerState, change.newStats);
                            break;

                        case 'new-piece':
                            playerState.currentPiece = change.currentPiece;
                            playerState.nextPiece = change.nextPiece;
                            playerState.currentX = 4;
                            playerState.currentY = 0;
                            break;

                        case 'game-over':
                            this.handleGameOver({
                                winner: change.winner,
                                finalScores: change.finalScores
                            });
                            break;
                    }
                });
            }

            // Game Over Handling
            handleGameOver(result) {
                this.gameState.winner = result.winner;
                
                const message = result.winner === 'draw' 
                    ? '‡πÄ‡∏™‡∏°‡∏≠!' 
                    : `‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô ${result.winner} ‡∏ä‡∏ô‡∏∞!`;
                
                document.getElementById('winner-message').textContent = message;
                document.getElementById('final-score-p1').textContent = result.finalScores.player1;
                document.getElementById('final-score-p2').textContent = result.finalScores.player2;
                
                showScreen('game-over-screen');
            }

            // Utility Methods
            updateStatus(message) {
                const statusEl = document.getElementById('status');
                if (statusEl) {
                    statusEl.textContent = message;
                }
            }

            startGameLoop() {
                if (this.dropInterval) {
                    clearInterval(this.dropInterval);
                }

                this.dropInterval = setInterval(() => {
                    if (this.gameState?.gameStarted && this.socket?.connected) {
                        this.socket.emit('game-action', { type: 'move-down' });
                    }
                }, 1000);
            }

            // Canvas and Rendering Methods
            setupCanvas() {
                this.canvas = document.getElementById('game-canvas');
                if (!this.canvas) return;
                
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = 800;
                this.canvas.height = 600;
                
                this.ctx.imageSmoothingEnabled = false;
                this.blockTextures = this.createBlockTextures();
            }

            createBlockTextures() {
                const textures = {};
                const colors = {
                    'block-i': '#00f0f0',
                    'block-o': '#f0f000', 
                    'block-t': '#a000f0',
                    'block-s': '#00f000',
                    'block-z': '#f00000',
                    'block-j': '#0000f0',
                    'block-l': '#f0a000'
                };

                Object.entries(colors).forEach(([type, color]) => {
                    const canvas = document.createElement('canvas');
                    canvas.width = canvas.height = this.TILE_SIZE;
                    const ctx = canvas.getContext('2d');
                    
                    const gradient = ctx.createLinearGradient(0, 0, this.TILE_SIZE, this.TILE_SIZE);
                    gradient.addColorStop(0, color);
                    gradient.addColorStop(1, this.darkenColor(color, 0.3));
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, this.TILE_SIZE, this.TILE_SIZE);
                    
                    ctx.strokeStyle = this.lightenColor(color, 0.2);
                    ctx.lineWidth = 2;
                    ctx.strokeRect(1, 1, this.TILE_SIZE-2, this.TILE_SIZE-2);
                    
                    textures[type] = canvas;
                });

                return textures;
            }

            startRenderLoop() {
                const render = (currentTime) => {
                    this.performanceMetrics.frameCount++;
                    if (currentTime - this.performanceMetrics.lastTime >= 1000) {
                        this.performanceMetrics.fps = this.performanceMetrics.frameCount;
                        this.performanceMetrics.frameCount = 0;
                        this.performanceMetrics.lastTime = currentTime;
                    }

                    if (this.hasStateChanged()) {
                        this.renderGame();
                        this.prevGameState = this.deepCloneState(this.gameState);
                    }

                    this.animationFrame = requestAnimationFrame(render);
                };

                this.animationFrame = requestAnimationFrame(render);
            }

            hasStateChanged() {
                if (!this.gameState || !this.prevGameState) return true;
                
                const current = this.gameState;
                const prev = this.prevGameState;
                
                return (
                    current.player1?.currentX !== prev.player1?.currentX ||
                    current.player1?.currentY !== prev.player1?.currentY ||
                    current.player1?.score !== prev.player1?.score ||
                    current.player2?.currentX !== prev.player2?.currentX ||
                    current.player2?.currentY !== prev.player2?.currentY ||
                    current.player2?.score !== prev.player2?.score ||
                    this.hasGridChanged(current.player1?.grid, prev.player1?.grid) ||
                    this.hasGridChanged(current.player2?.grid, prev.player2?.grid)
                );
            }

            hasGridChanged(grid1, grid2) {
                if (!grid1 || !grid2) return true;
                
                for (let row = 0; row < grid1.length; row++) {
                    for (let col = 0; col < grid1[row].length; col++) {
                        if (grid1[row][col] !== grid2[row][col]) {
                            return true;
                        }
                    }
                }
                return false;
            }

            renderGame() {
                if (!this.gameState || !this.ctx) return;

                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw background
                this.drawBackground();

                if (this.gameState.gameStarted) {
                    // Draw both player grids
                    this.drawPlayerGrid(this.gameState.player1, 50, 50);
                    this.drawPlayerGrid(this.gameState.player2, 450, 50);

                    // Draw game info
                    this.drawGameInfo();
                }
            }

            drawBackground() {
                const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
                gradient.addColorStop(0, 'rgba(20, 20, 40, 0.8)');
                gradient.addColorStop(1, 'rgba(40, 20, 60, 0.8)');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            drawPlayerGrid(player, offsetX, offsetY) {
                if (!player || !player.grid) return;

                const gridWidth = 10;
                const gridHeight = 20;

                // Draw grid background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.fillRect(offsetX, offsetY, gridWidth * this.TILE_SIZE, gridHeight * this.TILE_SIZE);

                // Draw grid lines
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 1;
                for (let row = 0; row <= gridHeight; row++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(offsetX, offsetY + row * this.TILE_SIZE);
                    this.ctx.lineTo(offsetX + gridWidth * this.TILE_SIZE, offsetY + row * this.TILE_SIZE);
                    this.ctx.stroke();
                }
                for (let col = 0; col <= gridWidth; col++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(offsetX + col * this.TILE_SIZE, offsetY);
                    this.ctx.lineTo(offsetX + col * this.TILE_SIZE, offsetY + gridHeight * this.TILE_SIZE);
                    this.ctx.stroke();
                }

                // Draw placed blocks
                for (let row = 0; row < player.grid.length; row++) {
                    for (let col = 0; col < player.grid[row].length; col++) {
                        if (player.grid[row][col]) {
                            this.drawBlock(
                                offsetX + col * this.TILE_SIZE,
                                offsetY + row * this.TILE_SIZE,
                                player.grid[row][col]
                            );
                        }
                    }
                }

                // Draw current piece
                if (player.currentPiece && player.currentPiece.shape) {
                    this.drawPiece(
                        player.currentPiece.shape,
                        offsetX + player.currentX * this.TILE_SIZE,
                        offsetY + player.currentY * this.TILE_SIZE,
                        player.currentPiece.type
                    );
                }

                // Draw player info
                this.drawPlayerInfo(player, offsetX, offsetY - 30);
            }

            drawBlock(x, y, blockType) {
                const texture = this.blockTextures[blockType];
                if (texture) {
                    this.ctx.drawImage(texture, x, y);
                } else {
                    // Fallback color
                    this.ctx.fillStyle = this.getBlockColor(blockType);
                    this.ctx.fillRect(x, y, this.TILE_SIZE, this.TILE_SIZE);
                    
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(x, y, this.TILE_SIZE, this.TILE_SIZE);
                }
            }

            drawPiece(shape, x, y, pieceType) {
                for (let row = 0; row < shape.length; row++) {
                    for (let col = 0; col < shape[row].length; col++) {
                        if (shape[row][col]) {
                            this.drawBlock(
                                x + col * this.TILE_SIZE,
                                y + row * this.TILE_SIZE,
                                `block-${pieceType}`
                            );
                        }
                    }
                }
            }

            drawPlayerInfo(player, x, y) {
                this.ctx.fillStyle = '#fff';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'left';
                
                const playerNum = player === this.gameState.player1 ? '1' : '2';
                const isCurrentPlayer = parseInt(playerNum) === this.playerNumber;
                
                this.ctx.fillStyle = isCurrentPlayer ? '#ffd700' : '#fff';
                this.ctx.fillText(`Player ${playerNum}`, x, y);
                
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '14px Arial';
                this.ctx.fillText(`Score: ${player.score || 0}`, x, y + 20);
                this.ctx.fillText(`Lines: ${player.lines || 0}`, x + 120, y + 20);
                this.ctx.fillText(`Level: ${player.level || 1}`, x + 200, y + 20);
            }

            drawGameInfo() {
                // Draw FPS counter
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(10, 10, 100, 30);
                
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`FPS: ${this.performanceMetrics.fps}`, 15, 30);
            }

            getBlockColor(blockType) {
                const colors = {
                    'block-i': '#00f0f0',
                    'block-o': '#f0f000',
                    'block-t': '#a000f0',
                    'block-s': '#00f000',
                    'block-z': '#f00000',
                    'block-j': '#0000f0',
                    'block-l': '#f0a000'
                };
                return colors[blockType] || '#666';
            }

            darkenColor(color, factor) {
                const hex = color.replace('#', '');
                const r = Math.max(0, parseInt(hex.substr(0, 2), 16) * (1 - factor));
                const g = Math.max(0, parseInt(hex.substr(2, 2), 16) * (1 - factor));
                const b = Math.max(0, parseInt(hex.substr(4, 2), 16) * (1 - factor));
                return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
            }

            lightenColor(color, factor) {
                const hex = color.replace('#', '');
                const r = Math.min(255, parseInt(hex.substr(0, 2), 16) * (1 + factor));
                const g = Math.min(255, parseInt(hex.substr(2, 2), 16) * (1 + factor));
                const b = Math.min(255, parseInt(hex.substr(4, 2), 16) * (1 + factor));
                return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
            }

            deepCloneState(state) {
                if (!state) return null;
                return JSON.parse(JSON.stringify(state));
            }

            // Single Player Mode
            startSinglePlayer() {
                showScreen('game-screen');
                this.initializeSinglePlayerGame();
                this.startSinglePlayerLoop();
            }

            initializeSinglePlayerGame() {
                this.singlePlayerState = {
                    grid: Array(20).fill().map(() => Array(10).fill(null)),
                    currentPiece: this.generateRandomPiece(),
                    nextPiece: this.generateRandomPiece(),
                    currentX: 4,
                    currentY: 0,
                    score: 0,
                    lines: 0,
                    level: 1,
                    gameOver: false
                };
            }

            generateRandomPiece() {
                const pieces = ['i', 'o', 't', 's', 'z', 'j', 'l'];
                const shapes = {
                    i: [[1,1,1,1]],
                    o: [[1,1],[1,1]],
                    t: [[0,1,0],[1,1,1]],
                    s: [[0,1,1],[1,1,0]],
                    z: [[1,1,0],[0,1,1]],
                    j: [[1,0,0],[1,1,1]],
                    l: [[0,0,1],[1,1,1]]
                };
                
                const type = pieces[Math.floor(Math.random() * pieces.length)];
                return {
                    type: type,
                    shape: shapes[type]
                };
            }

            startSinglePlayerLoop() {
                if (this.singlePlayerInterval) {
                    clearInterval(this.singlePlayerInterval);
                }

                const dropSpeed = Math.max(100, 1000 - (this.singlePlayerState.level - 1) * 100);
                
                this.singlePlayerInterval = setInterval(() => {
                    if (!this.singlePlayerState.gameOver) {
                        this.movePieceDown();
                    }
                }, dropSpeed);

                // Start render loop for single player
                this.renderSinglePlayer();
            }

            renderSinglePlayer() {
                if (!this.singlePlayerState || this.singlePlayerState.gameOver) return;

                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawBackground();

                // Draw single player grid (centered)
                const offsetX = (this.canvas.width - 10 * this.TILE_SIZE) / 2;
                const offsetY = 50;

                this.drawSinglePlayerGrid(offsetX, offsetY);
                this.drawSinglePlayerInfo();

                requestAnimationFrame(() => this.renderSinglePlayer());
            }

            drawSinglePlayerGrid(offsetX, offsetY) {
                const state = this.singlePlayerState;
                const gridWidth = 10;
                const gridHeight = 20;

                // Draw grid background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.fillRect(offsetX, offsetY, gridWidth * this.TILE_SIZE, gridHeight * this.TILE_SIZE);

                // Draw grid lines
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 1;
                for (let row = 0; row <= gridHeight; row++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(offsetX, offsetY + row * this.TILE_SIZE);
                    this.ctx.lineTo(offsetX + gridWidth * this.TILE_SIZE, offsetY + row * this.TILE_SIZE);
                    this.ctx.stroke();
                }
                for (let col = 0; col <= gridWidth; col++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(offsetX + col * this.TILE_SIZE, offsetY);
                    this.ctx.lineTo(offsetX + col * this.TILE_SIZE, offsetY + gridHeight * this.TILE_SIZE);
                    this.ctx.stroke();
                }

                // Draw placed blocks
                for (let row = 0; row < state.grid.length; row++) {
                    for (let col = 0; col < state.grid[row].length; col++) {
                        if (state.grid[row][col]) {
                            this.drawBlock(
                                offsetX + col * this.TILE_SIZE,
                                offsetY + row * this.TILE_SIZE,
                                state.grid[row][col]
                            );
                        }
                    }
                }

                // Draw current piece
                if (state.currentPiece && state.currentPiece.shape) {
                    this.drawPiece(
                        state.currentPiece.shape,
                        offsetX + state.currentX * this.TILE_SIZE,
                        offsetY + state.currentY * this.TILE_SIZE,
                        state.currentPiece.type
                    );
                }
            }

            drawSinglePlayerInfo() {
                const state = this.singlePlayerState;
                
                // Draw score panel
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(20, 50, 200, 150);
                
                this.ctx.fillStyle = '#fff';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('Single Player', 30, 75);
                
                this.ctx.font = '14px Arial';
                this.ctx.fillText(`Score: ${state.score}`, 30, 100);
                this.ctx.fillText(`Lines: ${state.lines}`, 30, 120);
                this.ctx.fillText(`Level: ${state.level}`, 30, 140);
                
                // Draw next piece
                this.ctx.fillText('Next:', 30, 170);
                if (state.nextPiece && state.nextPiece.shape) {
                    this.drawPiece(
                        state.nextPiece.shape,
                        30,
                        180,
                        state.nextPiece.type
                    );
                }
            }

            // Cleanup
            destroy() {
                if (this.dropInterval) {
                    clearInterval(this.dropInterval);
                }
                if (this.singlePlayerInterval) {
                    clearInterval(this.singlePlayerInterval);
                }
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
                if (this.socket) {
                    this.socket.disconnect();
                }
            }
        }

        // Event Listeners for UI
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize game client
            gameClient = new OptimizedTetrisClient();

            // Menu button handlers
            document.getElementById('btn-create-room').addEventListener('click', () => {
                showScreen('create-room-screen');
            });

            document.getElementById('btn-join-room').addEventListener('click', () => {
                showScreen('join-room-screen');
            });

            document.getElementById('btn-single-player').addEventListener('click', () => {
                gameClient.startSinglePlayer();
            });

            // Create room handler
            document.getElementById('btn-confirm-create').addEventListener('click', () => {
                const playerName = document.getElementById('create-player-name').value.trim();
                if (playerName) {
                    gameClient.createRoom(playerName);
                } else {
                    alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô');
                }
            });

            // Join room handler
            document.getElementById('btn-confirm-join').addEventListener('click', () => {
                const playerName = document.getElementById('join-player-name').value.trim();
                const roomId = document.getElementById('join-room-id').value.trim();
                
                if (playerName && roomId) {
                    gameClient.joinRoom(roomId, playerName);
                } else {
                    alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÅ‡∏•‡∏∞‡∏£‡∏´‡∏±‡∏™‡∏´‡πâ‡∏≠‡∏á');
                }
            });

            // Ready button handler
            document.getElementById('btn-ready').addEventListener('click', () => {
                gameClient.playerReady();
                document.getElementById('btn-ready').disabled = true;
            });

            // Leave room handler
            document.getElementById('btn-leave-room').addEventListener('click', () => {
                gameClient.leaveRoom();
            });

            // Play again handler
            document.getElementById('btn-play-again').addEventListener('click', () => {
                if (gameClient.socket && gameClient.socket.connected) {
                    gameClient.socket.emit('play-again');
                    showScreen('waiting-screen');
                    document.getElementById('btn-ready').disabled = false;
                }
            });
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (gameClient) {
                gameClient.destroy();
            }
        });
    </script>
</body>
</html>
