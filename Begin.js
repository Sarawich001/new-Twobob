// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏•‡πà‡∏ô‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏Ñ‡∏ô
function updateReadyStatus(data) {
    try {
        const indicator1 = document.getElementById('ready-indicator-1');
        const indicator2 = document.getElementById('ready-indicator-2');
        
        if (indicator1 && data.player1) {
            indicator1.textContent = `${data.player1.name}: ${data.player1.ready ? '‡∏û‡∏£‡πâ‡∏≠‡∏° ‚úÖ' : '‡∏£‡∏≠... ‚è≥'}`;
        }
        if (indicator2 && data.player2) {
            indicator2.textContent = `${data.player2.name}: ${data.player2.ready ? '‡∏û‡∏£‡πâ‡∏≠‡∏° ‚úÖ' : '‡∏£‡∏≠... ‚è≥'}`;
        }
    } catch (error) {
        console.error('Error updating ready status:', error);
    }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏Å‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°
function initGame(gameData) {
    try {
        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô‡πÄ‡∏Å‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏Ñ‡∏ô
        initGameBoard('my-board', 20, 10);
        initGameBoard('opponent-board', 20, 10);
        
        // Set player names
        const myNameEl = document.getElementById('my-player-name');
        const oppNameEl = document.getElementById('opponent-player-name');
        
        if (myNameEl && gameState.currentPlayer) {
            myNameEl.textContent = gameState.currentPlayer.name || 'YOU';
        }
        if (oppNameEl) {
            oppNameEl.textContent = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏£‡∏≠...';
        }
        
        // Reset scores
        resetGameStats();
        
        // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÄ‡∏Å‡∏°
        initGameControls();
    } catch (error) {
        console.error('Error initializing game:', error);
    }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡πÄ‡∏Å‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
function resetGameStats() {
    try {
        const elements = {
            'my-score': '0',
            'my-lines': '0',
            'my-level': '1',
            'opponent-score': '0',
            'opponent-lines': '0',
            'opponent-level': '1'
        };
        
        Object.entries(elements).forEach(([id, value]) => {
            const el = document.getElementById(id);
            if (el) {
                el.textContent = value;
            }
        });
    } catch (error) {
        console.error('Error resetting game stats:', error);
    }
}
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
function updateGameDisplay(gameData) {
    try {
        // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡πÅ‡∏•‡∏∞‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
        if (gameData.players && gameState.currentPlayer) {
            const myData = gameData.players[gameState.currentPlayer.id];
            const opponentData = Object.values(gameData.players).find(p => p.id !== gameState.currentPlayer.id);
            
            if (myData) {
                const myScore = document.getElementById('my-score');
                const myLines = document.getElementById('my-lines');
                const myLevel = document.getElementById('my-level');
                
                if (myScore) myScore.textContent = myData.score || 0;
                if (myLines) myLines.textContent = myData.lines || 0;
                if (myLevel) myLevel.textContent = myData.level || 1;
                
            }
            
            if (opponentData) {
                const oppName = document.getElementById('opponent-player-name');
                const oppScore = document.getElementById('opponent-score');
                const oppLines = document.getElementById('opponent-lines');
                const oppLevel = document.getElementById('opponent-level');
                
                if (oppName) oppName.textContent = opponentData.name || '‡∏ù‡πà‡∏≤‡∏¢‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°';
                if (oppScore) oppScore.textContent = opponentData.score || 0;
                if (oppLines) oppLines.textContent = opponentData.lines || 0;
                if (oppLevel) oppLevel.textContent = opponentData.level || 1;
            }
        }
        
        // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô‡πÄ‡∏Å‡∏°‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏Ñ‡∏ô
        if (gameData.boards && gameState.currentPlayer) {
            updateBoard('my-board', gameData.boards[gameState.currentPlayer.id]);
            const opponentId = Object.keys(gameData.boards).find(id => id !== gameState.currentPlayer.id);
            if (opponentId) {
                updateBoard('opponent-board', gameData.boards[opponentId]);
            }
        }
        
        // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Ç‡∏≠‡∏á‡∏ä‡∏¥‡πâ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ï‡πà‡∏≠‡πÑ‡∏õ
        if (gameData.nextPieces && gameState.currentPlayer && gameData.nextPieces[gameState.currentPlayer.id]) {
            updateNextPiece(gameData.nextPieces[gameState.currentPlayer.id]);
        }
    } catch (error) {
        console.error('Error updating game display:', error);
    }
}
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏≤‡∏î‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏ö‡∏ô‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô
function updateBoard(boardId, boardData) {
    try {
        if (!boardData) return;
        
        const board = document.getElementById(boardId);
        if (!board) return;
        
        const cellSize = boardId === 'my-board' ? 32 : 16;
        
        // ‡∏•‡∏ö‡∏ä‡∏¥‡πâ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡πÄ‡∏Å‡∏°‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÄ‡∏î‡∏¥‡∏° (‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô‡πÄ‡∏ã‡∏•‡∏•‡πå‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á)
        const gamePieces = board.querySelectorAll('.tetris-block:not(.grid-cell)');
        gamePieces.forEach(piece => piece.remove());
        
        // ‡∏ß‡∏≤‡∏î‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏ó‡∏µ‡πà‡∏ß‡∏≤‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
        if (boardData.grid && Array.isArray(boardData.grid)) {
            boardData.grid.forEach((row, r) => {
                if (Array.isArray(row)) {
                    row.forEach((cell, c) => {
                        if (cell) {
                            const block = document.createElement('div');
                            block.className = `tetris-block block-${cell}`;
                            block.style.width = cellSize + 'px';
                            block.style.height = cellSize + 'px';
                            block.style.left = (c * cellSize) + 'px';
                            block.style.top = (r * cellSize) + 'px';
                            block.style.position = 'absolute';
                            board.appendChild(block);
                        }
                    });
                }
            });
        }
        
        // ‡∏ß‡∏≤‡∏î‡∏ä‡∏¥‡πâ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà
        if (boardData.currentPiece) {
            drawCurrentPiece(boardId, boardData.currentPiece, cellSize);
        }
    } catch (error) {
        console.error('Error updating board:', error);
    }
}
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Ç‡∏≠‡∏á‡∏ä‡∏¥‡πâ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ï‡πà‡∏≠‡πÑ‡∏õ
function updateNextPiece(nextPieceData) {
    try {
        const nextPieceContainer = document.getElementById('next-piece-preview');
        if (!nextPieceContainer) return;
        
        nextPieceContainer.innerHTML = '';
        
        if (nextPieceData && nextPieceData.shape && Array.isArray(nextPieceData.shape)) {
            const blockSize = 20;
            
            nextPieceData.shape.forEach((row, r) => {
                if (Array.isArray(row)) {
                    row.forEach((cell, c) => {
                        if (cell) {
                            const block = document.createElement('div');
                            block.className = `tetris-block block-${nextPieceData.type}`;
                            block.style.width = blockSize + 'px';
                            block.style.height = blockSize + 'px';
                            block.style.left = (c * blockSize) + 'px';
                            block.style.top = (r * blockSize) + 'px';
                            block.style.position = 'absolute';
                            nextPieceContainer.appendChild(block);
                        }
                    });
                }
            });
        }
    } catch (error) {
        console.error('Error updating next piece:', error);
    }
}
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÄ‡∏Å‡∏°‡πÇ‡∏≠‡πÄ‡∏ß‡∏≠‡∏£‡πå
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÄ‡∏Å‡∏°‡πÇ‡∏≠‡πÄ‡∏ß‡∏≠‡∏£‡πå (‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÅ‡∏•‡πâ‡∏ß)
function showGameOver(data) {
    try {
        const winnerMessage = document.getElementById('winner-message');
        const finalScoreP1 = document.getElementById('final-score-p1');
        const finalScoreP2 = document.getElementById('final-score-p2');
        const finalNameP1 = document.getElementById('final-name-p1');
        const finalNameP2 = document.getElementById('final-name-p2');
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ data ‡πÅ‡∏•‡∏∞ gameState.currentPlayer
        if (!data || !gameState.currentPlayer) {
            console.error('Missing game over data or current player');
            return;
        }
        
        if (winnerMessage) {
            if (data.winner === gameState.currentPlayer.id) {
                winnerMessage.textContent = 'üéâ ‡∏Ñ‡∏∏‡∏ì‡∏ä‡∏ô‡∏∞!';
                winnerMessage.style.color = '#4CAF50';
            } else {
                winnerMessage.textContent = 'üò¢ ‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏û‡πâ!';
                winnerMessage.style.color = '#f44336';
            }
        }
        
        // ‡∏î‡∏∂‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏à‡∏≤‡∏Å‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÄ‡∏Å‡∏°‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏™‡∏î‡∏á‡∏≠‡∏¢‡∏π‡πà
        const myPlayerNameEl = document.getElementById('my-player-name');
        const opponentPlayerNameEl = document.getElementById('opponent-player-name');
        
        const myDisplayName = myPlayerNameEl ? myPlayerNameEl.textContent : '‡∏Ñ‡∏∏‡∏ì';
        const opponentDisplayName = opponentPlayerNameEl ? opponentPlayerNameEl.textContent : '‡∏ù‡πà‡∏≤‡∏¢‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°';
        
        // ‡πÅ‡∏™‡∏î‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏ó‡∏µ‡πà‡∏î‡∏∂‡∏á‡∏°‡∏≤‡∏à‡∏≤‡∏Å‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÄ‡∏Å‡∏°
        if (finalNameP1) {
            finalNameP1.textContent = myDisplayName;
        }
        if (finalNameP2) {
            finalNameP2.textContent = opponentDisplayName;
        }
        
        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏à‡∏≤‡∏Å data ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö
        if (data.finalScores && data.players) {
            const currentPlayerId = gameState.currentPlayer.id.toString();
            const opponentId = Object.keys(data.players).find(id => id !== currentPlayerId);
            
            if (finalScoreP1) {
                finalScoreP1.textContent = data.finalScores[currentPlayerId] || 0;
            }
            if (finalScoreP2) {
                finalScoreP2.textContent = data.finalScores[opponentId] || 0;
            }
        } else {
            // ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏à‡∏≤‡∏Å‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÄ‡∏Å‡∏°‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å server
            const myScoreEl = document.getElementById('my-score');
            const opponentScoreEl = document.getElementById('opponent-score');
            
            if (finalScoreP1) {
                finalScoreP1.textContent = myScoreEl ? myScoreEl.textContent : '0';
            }
            if (finalScoreP2) {
                finalScoreP2.textContent = opponentScoreEl ? opponentScoreEl.textContent : '0';
            }
        }
        
        showScreen('game-over-screen');
    } catch (error) {
        console.error('Error showing game over:', error);
    }
}
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏°‡∏ô‡∏π‡∏¢‡∏∑‡∏î‡∏´‡∏î (Accordion)
function initControlsAccordion() {
    try {
        const toggleBtn = document.getElementById('controls-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', () => {
                const content = document.getElementById('controls-content');
                const icon = document.getElementById('toggle-icon');
                
                if (content && icon) {
                    if (content.classList.contains('expanded')) {
                        content.classList.remove('expanded');
                        icon.classList.remove('rotated');
                    } else {
                        content.classList.add('expanded');
                        icon.classList.add('rotated');
                    }
                }
            });
        }
    } catch (error) {
        console.error('Error initializing controls accordion:', error);
    }
}

/**
 * Tetris Game Functions - ‡πÅ‡∏¢‡∏Å‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å TetrisMultiplayer class
 * ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡∏° Tetris ‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ô‡∏≥‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏∑‡πà‡∏ô‡πÑ‡∏î‡πâ
 */

/**
 * ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°
 */
function startGame(data) {
    this.gameStarted = true;
    this.gameState.gameOver = false;
    this.gameState.score = 0;
    this.gameState.lines = 0;
    this.gameState.level = 1;
    this.moveInterval = 500;
    this.lastMoveTime = 0;
    
    this.initializeBoard();
    this.gameState.currentPiece = this.generatePiece();
    this.gameState.nextPiece = this.generatePiece();
    
    this.setupGameLayout();
    this.showScreen('game-screen');
    
    this.updateBoard();
    this.updateStats();
    this.updateNextPiece();
    
    this.gameLoop();
}

/**
 * ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ä‡∏¥‡πâ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡πÉ‡∏´‡∏°‡πà
 */
function generatePiece() {
    const type = this.pieceTypes[Math.floor(Math.random() * this.pieceTypes.length)];
    return {
        type: type,
        shape: this.pieces[type].shape,
        color: this.pieces[type].color,
        x: Math.floor(this.BOARD_WIDTH / 2) - 1,
        y: 0
    };
}

/**
 * ‡∏´‡∏°‡∏∏‡∏ô‡∏ä‡∏¥‡πâ‡∏ô‡∏™‡πà‡∏ß‡∏ô
 */
function rotatePiece() {
    if (!this.gameState.currentPiece) return;
    
    const rotated = this.rotateMatrix(this.gameState.currentPiece.shape);
    if (this.isValidPosition(rotated, this.gameState.currentPiece.x, this.gameState.currentPiece.y)) {
        this.gameState.currentPiece.shape = rotated;
        this.updateBoard();
        
        // Visual feedback for rotation
        this.showRotationFeedback();
    }
}

/**
 * ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ä‡∏¥‡πâ‡∏ô‡∏™‡πà‡∏ß‡∏ô
 */
function movePiece(dx, dy) {
    if (!this.gameState.currentPiece) return false;
    
    const newX = this.gameState.currentPiece.x + dx;
    const newY = this.gameState.currentPiece.y + dy;
    
    if (this.isValidPosition(this.gameState.currentPiece.shape, newX, newY)) {
        this.gameState.currentPiece.x = newX;
        this.gameState.currentPiece.y = newY;
        this.updateBoard();
        return true;
    }
    return false;
}

/**
 * ‡∏•‡∏π‡∏õ‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡∏°
 */
function gameLoop() {
    if (!this.gameStarted || this.gameState.gameOver) return;
    
    const now = Date.now();
    if (now - this.lastMoveTime > this.moveInterval) {
        if (!this.movePiece(0, 1)) {
            this.placePiece();
            this.clearLines();
            this.spawnNewPiece();
            this.sendGameUpdate();
        }
        this.lastMoveTime = now;
    }
    
    requestAnimationFrame(() => this.gameLoop());
}

/**
 * ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£ hard drop
 */
function hardDrop() {
    if (!this.gameState.currentPiece) return;
    
    let dropDistance = 0;
    while (this.movePiece(0, 1)) {
        dropDistance++;
    }
    
    // Bonus points for hard drop
    if (dropDistance > 0) {
        this.gameState.score += dropDistance * 2;
        this.updateStats();
    }
    
    // Visual feedback for hard drop
    this.showHardDropFeedback();
}

/**
 * ‡∏´‡∏°‡∏∏‡∏ô‡πÄ‡∏°‡∏ó‡∏£‡∏¥‡∏Å‡∏ã‡πå 90 ‡∏≠‡∏á‡∏®‡∏≤
 */
function rotateMatrix(matrix) {
    const rows = matrix.length;
    const cols = matrix[0].length;
    const rotated = Array(cols).fill().map(() => Array(rows).fill(0));
    
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            rotated[j][rows - 1 - i] = matrix[i][j];
        }
    }
    return rotated;
}

/**
 * ‡∏•‡πâ‡∏≤‡∏á‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà‡πÄ‡∏ï‡πá‡∏°
 */
function clearLines() {
    let linesCleared = 0;
    for (let i = this.BOARD_HEIGHT - 1; i >= 0; i--) {
        if (this.gameState.board[i].every(cell => cell !== 0)) {
            this.gameState.board.splice(i, 1);
            this.gameState.board.unshift(Array(this.BOARD_WIDTH).fill(0));
            linesCleared++;
            i++; // Check same line again
        }
    }
    
    if (linesCleared > 0) {
        this.gameState.lines += linesCleared;
        this.gameState.score += linesCleared * 100 * this.gameState.level;
        this.gameState.level = Math.floor(this.gameState.lines / 10) + 1;
        this.moveInterval = Math.max(50, 500 - (this.gameState.level - 1) * 50);
        this.updateStats();
        
        // Visual feedback for line clear
        this.showLineClearFeedback(linesCleared);
        
        // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó next piece ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å clear lines
        this.updateNextPiece();
    }
}

/**
 * ‡∏ß‡∏≤‡∏á‡∏ä‡∏¥‡πâ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏•‡∏á‡∏ö‡∏≠‡∏£‡πå‡∏î
 */
function placePiece() {
    if (!this.gameState.currentPiece) return;
    
    const { shape, x, y, color } = this.gameState.currentPiece;
    for (let i = 0; i < shape.length; i++) {
        for (let j = 0; j < shape[i].length; j++) {
            if (shape[i][j] && y + i >= 0) {
                this.gameState.board[y + i][x + j] = color;
            }
        }
    }
}

/**
 * ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ä‡∏¥‡πâ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡πÉ‡∏´‡∏°‡πà
 */
function spawnNewPiece() {
    this.gameState.currentPiece = this.gameState.nextPiece;
    this.gameState.nextPiece = this.generatePiece();
    
    this.updateNextPiece();
    
    if (!this.isValidPosition(this.gameState.currentPiece.shape, 
                              this.gameState.currentPiece.x, 
                              this.gameState.currentPiece.y)) {
        this.gameState.gameOver = true;
        this.socket.emit('gameOver', { 
            roomId: this.roomId, 
            playerId: this.playerId,
            score: this.gameState.score 
        });
    }
}

/**
 * ‡∏à‡∏ö‡πÄ‡∏Å‡∏°
 */
function endGame(data) {
    this.gameStarted = false;
    this.gameState.gameOver = true;
    
    const winnerMsg = document.getElementById('winner-message');
    if (winnerMsg) {
        winnerMsg.textContent = data.winner === this.playerId ? 'üéâ ‡∏Ñ‡∏∏‡∏ì‡∏ä‡∏ô‡∏∞!' : 'üò¢ ‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏û‡πâ';
    }
    
    const finalScoreP1 = document.getElementById('final-score-p1');
    const finalScoreP2 = document.getElementById('final-score-p2');
    if (finalScoreP1) finalScoreP1.textContent = data.scores.player1 || 0;
    if (finalScoreP2) finalScoreP2.textContent = data.scores.player2 || 0;
    
    this.showScreen('game-over-screen');
}

/**
 * ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ñ‡∏ß‡∏≤‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°
 */
function updateReadyStatus(players) {
    players.forEach((player, index) => {
        const indicator = document.getElementById(`ready-indicator-${index + 1}`);
        if (indicator) {
            indicator.textContent = `${player.name}: ${player.ready ? '‚úÖ ‡∏û‡∏£‡πâ‡∏≠‡∏°' : '‚è≥ ‡∏£‡∏≠...'}`;
        }
    });
}

// Export for Node.js
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        startGame,
        generatePiece,
        rotatePiece,
        movePiece,
        gameLoop,
        hardDrop,
        rotateMatrix,
        clearLines,
        placePiece,
        spawnNewPiece,
        endGame,
        updateReadyStatus
    };
}

// For browser use
if (typeof window !== 'undefined') {
    window.TetrisGameFunctions = {
        startGame,
        generatePiece,
        rotatePiece,
        movePiece,
        gameLoop,
        hardDrop,
        rotateMatrix,
        clearLines,
        placePiece,
        spawnNewPiece,
        endGame,
        updateReadyStatus
    };
}
